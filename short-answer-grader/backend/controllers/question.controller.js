/**
 * Question controller
 */
const Question = require('../models/Question');
const Rubric = require('../models/Rubric');
const mlService = require('../utils/mlService');

/**
 * Create a new question
 * POST /api/questions
 */
const createQuestion = async (req, res) => {
    try {
        const {
            title,
            content,
            referenceAnswer,
            maxScore,
            subject,
            topic,
            difficulty,
            dueDate,
            tags,
            autoGenerateRubric
        } = req.body;
        
        // Create question
        const question = new Question({
            title,
            content,
            referenceAnswer,
            maxScore: maxScore || 100,
            subject,
            topic,
            difficulty,
            dueDate,
            tags,
            createdBy: req.userId
        });
        
        await question.save();
        
        // Auto-generate rubric if requested
        if (autoGenerateRubric && referenceAnswer) {
            try {
                console.log('Auto-generating rubric for question:', question._id);
                
                let rubricDims = [];
                
                // Try to use ML service first
                try {
                    const mlHealth = await mlService.checkHealth();
                    if (mlHealth.healthy) {
                        rubricDims = await mlService.withRetry(() =>
                            mlService.splitIntoRubricDims(referenceAnswer)
                        );
                        console.log('ML service returned dimensions:', rubricDims);
                    }
                } catch (mlError) {
                    console.warn('ML service unavailable, using fallback:', mlError.message);
                }
                
                // Fallback: use simple heuristic splitting if ML service fails or returns empty
                if (!rubricDims || rubricDims.length === 0) {
                    rubricDims = referenceAnswer
                        .split(/[.;]/)
                        .map(s => s.trim())
                        .filter(s => s.length > 10)
                        .slice(0, 5);
                    console.log('Fallback dimensions:', rubricDims);
                }
                
                if (rubricDims.length > 0) {
                    const rubric = new Rubric({
                        name: `Rubric for: ${title.substring(0, 50)}`,
                        description: 'Auto-generated rubric from reference answer',
                        dimensions: rubricDims.map((dim, idx) => ({
                            name: `Criterion ${idx + 1}`,
                            description: typeof dim === 'string' ? dim : dim.text || dim.description || String(dim),
                            weight: 1.0 / rubricDims.length,
                            maxPoints: 100,
                            keywords: [],
                            order: idx
                        })),
                        question: question._id,
                        createdBy: req.userId,
                        isAutoGenerated: true,
                        isTemplate: false
                    });
                    
                    await rubric.save();
                    console.log('Rubric created:', rubric._id);
                    
                    question.rubric = rubric._id;
                    await question.save();
                    console.log('Question updated with rubric reference');
                }
            } catch (err) {
                console.error('Auto-rubric generation failed:', err);
                // Continue without rubric - not a critical error
            }
        }
        
        await question.populate('rubric');
        
        res.status(201).json({
            success: true,
            message: 'Question created successfully',
            data: question
        });
    } catch (error) {
        console.error('Create question error:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Failed to create question'
        });
    }
};

/**
 * Get all questions (for teacher) or active questions (for student)
 * GET /api/questions
 */
const getQuestions = async (req, res) => {
    try {
        const { subject, topic, difficulty, page = 1, limit = 20 } = req.query;
        
        const query = {};
        
        // Teachers see their own questions, students see all active
        if (req.user.role === 'teacher') {
            query.createdBy = req.userId;
        } else {
            query.isActive = true;
        }
        
        // Apply filters
        if (subject) query.subject = subject;
        if (topic) query.topic = topic;
        if (difficulty) query.difficulty = difficulty;
        
        const skip = (parseInt(page) - 1) * parseInt(limit);
        
        const [questions, total] = await Promise.all([
            Question.find(query)
                .populate('rubric')
                .populate('createdBy', 'name email')
                .sort({ createdAt: -1 })
                .skip(skip)
                .limit(parseInt(limit)),
            Question.countDocuments(query)
        ]);
        
        res.json({
            success: true,
            data: questions,
            pagination: {
                total,
                page: parseInt(page),
                limit: parseInt(limit),
                pages: Math.ceil(total / parseInt(limit))
            }
        });
    } catch (error) {
        console.error('Get questions error:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Failed to get questions'
        });
    }
};

/**
 * Get single question by ID
 * GET /api/questions/:id
 */
const getQuestion = async (req, res) => {
    try {
        const question = await Question.findById(req.params.id)
            .populate('rubric')
            .populate('createdBy', 'name email');
        
        if (!question) {
            return res.status(404).json({
                success: false,
                message: 'Question not found'
            });
        }
        
        // Check access
        if (req.user.role === 'student' && !question.isActive) {
            return res.status(403).json({
                success: false,
                message: 'This question is not available'
            });
        }
        
        res.json({
            success: true,
            data: question
        });
    } catch (error) {
        console.error('Get question error:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Failed to get question'
        });
    }
};

/**
 * Update question
 * PUT /api/questions/:id
 */
const updateQuestion = async (req, res) => {
    try {
        const question = await Question.findById(req.params.id);
        
        if (!question) {
            return res.status(404).json({
                success: false,
                message: 'Question not found'
            });
        }
        
        // Check ownership
        if (question.createdBy.toString() !== req.userId.toString()) {
            return res.status(403).json({
                success: false,
                message: 'Not authorized to update this question'
            });
        }
        
        const {
            title,
            content,
            referenceAnswer,
            maxScore,
            subject,
            topic,
            difficulty,
            dueDate,
            tags,
            isActive
        } = req.body;
        
        if (title) question.title = title;
        if (content) question.content = content;
        if (referenceAnswer) question.referenceAnswer = referenceAnswer;
        if (maxScore) question.maxScore = maxScore;
        if (subject !== undefined) question.subject = subject;
        if (topic !== undefined) question.topic = topic;
        if (difficulty) question.difficulty = difficulty;
        if (dueDate !== undefined) question.dueDate = dueDate;
        if (tags) question.tags = tags;
        if (isActive !== undefined) question.isActive = isActive;
        
        await question.save();
        await question.populate('rubric');
        
        res.json({
            success: true,
            message: 'Question updated successfully',
            data: question
        });
    } catch (error) {
        console.error('Update question error:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Failed to update question'
        });
    }
};

/**
 * Delete question
 * DELETE /api/questions/:id
 */
const deleteQuestion = async (req, res) => {
    try {
        const question = await Question.findById(req.params.id);
        
        if (!question) {
            return res.status(404).json({
                success: false,
                message: 'Question not found'
            });
        }
        
        // Check ownership
        if (question.createdBy.toString() !== req.userId.toString()) {
            return res.status(403).json({
                success: false,
                message: 'Not authorized to delete this question'
            });
        }
        
        // Also delete associated rubric if auto-generated
        if (question.rubric) {
            const rubric = await Rubric.findById(question.rubric);
            if (rubric && rubric.isAutoGenerated) {
                await Rubric.findByIdAndDelete(question.rubric);
            }
        }
        
        await Question.findByIdAndDelete(req.params.id);
        
        res.json({
            success: true,
            message: 'Question deleted successfully'
        });
    } catch (error) {
        console.error('Delete question error:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Failed to delete question'
        });
    }
};

/**
 * Get question statistics
 * GET /api/questions/:id/stats
 */
const getQuestionStats = async (req, res) => {
    try {
        const Submission = require('../models/Submission');
        
        const question = await Question.findById(req.params.id);
        
        if (!question) {
            return res.status(404).json({
                success: false,
                message: 'Question not found'
            });
        }
        
        // Check ownership for teachers
        if (req.user.role === 'teacher' && 
            question.createdBy.toString() !== req.userId.toString()) {
            return res.status(403).json({
                success: false,
                message: 'Not authorized to view stats for this question'
            });
        }
        
        const submissions = await Submission.find({ 
            question: req.params.id,
            status: 'graded'
        });
        
        if (submissions.length === 0) {
            return res.json({
                success: true,
                data: {
                    totalSubmissions: 0,
                    gradedSubmissions: 0,
                    averageScore: null,
                    minScore: null,
                    maxScore: null,
                    distribution: {}
                }
            });
        }
        
        const scores = submissions.map(s => s.overallScore).filter(s => s !== undefined);
        
        const stats = {
            totalSubmissions: await Submission.countDocuments({ question: req.params.id }),
            gradedSubmissions: submissions.length,
            averageScore: scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : null,
            minScore: scores.length > 0 ? Math.min(...scores) : null,
            maxScore: scores.length > 0 ? Math.max(...scores) : null,
            distribution: {
                excellent: scores.filter(s => s >= 0.8).length,
                good: scores.filter(s => s >= 0.6 && s < 0.8).length,
                partial: scores.filter(s => s >= 0.4 && s < 0.6).length,
                needsWork: scores.filter(s => s < 0.4).length
            }
        };
        
        res.json({
            success: true,
            data: stats
        });
    } catch (error) {
        console.error('Get question stats error:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Failed to get question stats'
        });
    }
};

module.exports = {
    createQuestion,
    getQuestions,
    getQuestion,
    updateQuestion,
    deleteQuestion,
    getQuestionStats
};